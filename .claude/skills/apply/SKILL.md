---
name: apply
description: 执行实现。基于提案文档执行编码和测试。当用户需要实现功能、写代码、写测试时使用。触发词：实现、编码、开发、apply。
---

# /apply - 执行实现

## 描述

基于已生成的提案文档，执行编码和测试。

**模式**：Auto 模式（默认全自动，支持阶段确认）

---

## 参数

- `$ARGUMENTS`：提案名称（可选，默认使用最新提案）

**选项**：
- `--step`：阶段确认模式，每阶段完成后等待确认
- `--skip-test`：跳过测试阶段（仅编码）

**示例**：
```
/apply user-register
/apply user-register --step
/apply --skip-test
```

---

## 执行流程

### Step 0: 确认提案

1. 确定目标提案目录（`.proposal/{feature-name}/`）
2. 检查文档完整性：
   - 1-requirements.md ✓
   - 2-design.md ✓
   - 3-api-spec.md ✓
   - 4-test-cases.md ✓
   - 5-tasks.md ✓
3. **[强制] 扫描所有文档中的 `[待确认]` 标记**：
   - 使用 grep 搜索所有 5 个文档中的 `[待确认]`
   - 如果发现任何 `[待确认]` 项，**必须停止执行**，输出错误并列出所有待确认项
   - **只有在所有 `[待确认]` 项都被处理后才能继续**
4. **[状态更新] 用 Edit 工具更新 `1-requirements.md` 顶部状态**：`草稿` → `已确认`
5. 显示任务摘要，确认开始

**待确认项检查失败输出：**
```
❌ 发现未处理的 [待确认] 项，无法继续执行

📋 待确认项列表：
├── 1-requirements.md:
│   └── L72: [待确认] 用户注册是否需要邮箱验证？
├── 2-design.md:
│   └── L45: [待确认] 密码加密算法使用 bcrypt 还是 argon2？
│   └── L89: [待确认] 数据库表名前缀

👉 请先处理以上待确认项：
   1. 在对应文档中更新确认结果
   2. 删除 [待确认] 标记
   3. 重新运行 /apply
```

### Step 1: 编码阶段

**读取同目录下的 `CODING.md` 获取编码规范，按规范完成编码。**

**输入文档**：
- `.proposal/{feature}/1-requirements.md`
- `.proposal/{feature}/2-design.md`
- `.proposal/{feature}/3-api-spec.md`

**执行**：
1. 根据设计文档逐层实现代码
2. 每个文件创建后验证编译/构建
3. **【实时更新】每完成一个编码任务，立即用 Edit 工具更新 `5-tasks.md`**：
   - 将对应任务的 `[ ]` 改为 `[x]`
   - 示例：完成 C-1 后，更新 `| C-1 | ... | [ ] |` → `| C-1 | ... | [x] |`

**阶段完成输出**：
```
✅ 编码完成
├── 创建文件: X 个
├── 编译状态: 通过
└── 耗时: Xm Xs

[--step 模式] 是否继续单元测试？(y/n)
```

### Step 2: 单元测试阶段

**读取同目录下的 `UNIT-TEST.md` 获取测试规范，按规范编写单元测试。**

**输入文档**：
- `.proposal/{feature}/1-requirements.md`
- `.proposal/{feature}/4-test-cases.md`（UT-* 部分）
- 已实现的业务层代码

**执行**：
1. 创建测试文件
2. 运行测试
3. 如果失败，自动分析并修复（最多 3 次）
4. **【实时更新】每完成一个测试任务，立即用 Edit 工具更新 `5-tasks.md`**：
   - 将对应任务的 `[ ]` 改为 `[x]`
   - 示例：完成 T-1 后，更新 `| T-1 | ... | [ ] |` → `| T-1 | ... | [x] |`

**阶段完成输出**：
```
✅ 单元测试完成
├── 测试类: X 个
├── 测试方法: X 个
├── 通过: X 个
├── 失败: 0 个
└── 耗时: Xm Xs

[--step 模式] 是否继续 API 测试？(y/n)
```

### Step 3: API/集成测试阶段

**读取同目录下的 `API-TEST.md` 获取测试规范，按规范编写 API 测试。**

**输入文档**：
- `.proposal/{feature}/3-api-spec.md`
- `.proposal/{feature}/4-test-cases.md`（AT-* 部分）
- 已实现的接口层代码

**执行**：
1. 创建测试文件
2. 运行测试
3. 如果失败，自动分析并修复（最多 3 次）
4. **【实时更新】每完成一个测试任务，立即用 Edit 工具更新 `5-tasks.md`**：
   - 将对应任务的 `[ ]` 改为 `[x]`
   - 示例：完成 T-3 后，更新 `| T-3 | ... | [ ] |` → `| T-3 | ... | [x] |`

**阶段完成输出**：
```
✅ API 测试完成
├── 测试类: X 个
├── 测试方法: X 个
├── 通过: X 个
├── 失败: 0 个
└── 耗时: Xm Xs
```

### Step 4: 完成

1. **验证 `5-tasks.md` 所有任务已标记为 `[x]`**（各阶段已实时更新）
2. **用 Edit 工具更新 `5-tasks.md` 顶部状态**：`进行中` → `已完成`
3. **用 Edit 工具更新 `1-requirements.md` 顶部状态**：`已确认` → `已完成`
4. 运行全量测试验证
5. 输出最终摘要

---

## 输出

完成后显示：

```
✅ 实现完成：{feature-name}

📊 执行摘要：
├── 编码阶段
│   ├── 创建文件: X 个
│   ├── 修改文件: X 个
│   └── 编译: 通过
├── 单元测试
│   ├── 测试数: X 个
│   └── 通过率: 100%
└── API 测试
    ├── 测试数: X 个
    └── 通过率: 100%

📁 新增文件：
├── [根据实际项目结构列出]
└── ...

👉 下一步：
   1. 代码审查
   2. git add && git commit
   3. 创建 Pull Request
```

---

## 失败处理

### 编译失败

```
❌ 编译失败

错误信息：
[具体错误]

🔧 自动修复中...
[修复操作]

重新编译...
✅ 编译通过
```

### 测试失败

```
❌ 测试失败

失败用例：
- testXxx_Scenario: [错误信息]

🔧 自动修复中...
[分析原因]
[修复操作]

重新运行测试...
✅ 测试通过
```

### 多次失败

```
❌ 修复失败（已重试 3 次）

需要人工介入：
1. 检查错误信息
2. 手动修复后重新运行 /apply

最后的错误：
[错误详情]
```

---

## 注意事项

1. **文档完整性**：确保所有文档存在且无 `[待确认]` 项
2. **自动修复**：失败时自动分析并尝试修复
3. **进度追踪**：实时更新 tasks.md 中的任务状态
4. **可恢复**：失败后可以重新运行继续执行
